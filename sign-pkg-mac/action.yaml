name: sign-pkg-mac
description:
  Sign and package the macOS Alchemy viewer.

inputs:
  imagename:
    description: "Basename of installer .dmg"
    type: string
    required: true
  channel:
    description: "Viewer channel"
    type: string
    required: true
  cert_base64:
    description: "base64-encoded signing certificate"
    type: string
    required: false
  cert_name:
    description: "full name of signing certificate"
    type: string
    required: false
  cert_pass:
    description: "signing certificate password"
    type: string
    required: false
  note_user:
    description: "notarization Apple ID"
    type: string
    required: false
  note_pass:
    description: "password for note_user"
    type: string
    required: false
  note_team:
    description: "Team ID for note_user"
    type: string
    required: false
  channel_vendor_base:
    description: "setting for all steps"
    type: string
    required: false
    default: "Alchemy"

runs:
  using: composite
  steps:
    - name: Fetch Mac app
      uses: actions/download-artifact@v5
      with:
        name: macOS-app
        path: .tarball

    - name: Unpack the tarball and set vars
      id: unpack
      shell: bash
      run: |
        set -x
        mkdir -p ".app"
        tar xJf .tarball/* -C ".app"

        artifact_app="$(ls -dt .app/*.app | head -n 1)"
        echo "app_path=$artifact_app" >> "$GITHUB_ENV"

    - name: Setup Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.13'

    - name: Install Python dependencies
      shell: bash
      run: pip install "dmgbuild[badge_icons]"

    - name: Sign the app bundle
      if: inputs.cert_base64 && inputs.cert_name && inputs.cert_pass && inputs.note_user && inputs.note_pass && inputs.note_team
      shell: bash
      env:
        cert_base64: "${{ inputs.cert_base64 }}"
        cert_name: "${{ inputs.cert_name }}"
        cert_pass: "${{ inputs.cert_pass }}"
      run: |
        "${{ github.action_path }}/sign.sh" "${{ env.app_path }}"

    - name: Build DMG
      shell: bash
      run: |
        mkdir -p .installer
        dmgbuild -s "${{ github.action_path }}/dmgsettings.py" -D app="${{ env.app_path }}" "${{ inputs.channel_vendor_base }} Installer" .installer/${{ inputs.imagename }}.dmg
        installer=".installer/${{ inputs.imagename }}.dmg"
        echo "installer=$installer" >> "$GITHUB_ENV"

    - name: Sign and notarize the dmg
      if: inputs.cert_base64 && inputs.cert_name && inputs.cert_pass && inputs.note_user && inputs.note_pass && inputs.note_team
      shell: bash
      env:
        cert_name: "${{ inputs.cert_name }}"
        note_user: "${{ inputs.note_user }}"
        note_pass: "${{ inputs.note_pass }}"
        note_team: "${{ inputs.note_team }}"
      run: |
        codesign --verbose --force --timestamp --keychain viewer.keychain --sign "$cert_name" "${{ env.installer }}"

        set -x -e

        credentials=(--apple-id "$note_user" --password "$note_pass" --team-id "$note_team")

        # Here we send the notarization request to Apple's Notarization service,
        # waiting for the result. This typically takes a few seconds inside a CI
        # environment, but it might take more depending on the App characteristics.
        # Visit the Notarization docs for more information and strategies on how to
        # optimize it if you're curious.
        # emit notarytool output to stderr in real time but also capture in variable
        set +e
        output="$(xcrun notarytool submit "${{ env.installer }}" --wait \
                  "${credentials[@]}" 2>&1 | \
                  tee /dev/stderr ; \
                  exit "${PIPESTATUS[0]}")"
        # Without the final 'exit' above, we'd be checking the rc from 'tee' rather
        # than 'notarytool'.
        rc=$?
        set +x
        [[ "$output" =~ 'id: '([^[:space:]]+) ]]
        match=$?
        set -x
        # Run notarytool log if we find an id: anywhere in the output, regardless of
        # rc: notarytool can terminate with rc 0 even if it fails.
        if [[ $match -eq 0 ]]
        then
            xcrun notarytool log "${BASH_REMATCH[1]}" "${credentials[@]}"
        fi
        [[ $rc -ne 0 ]] && exit $rc
        set -e

        # Finally, we need to "attach the staple" to our executable, which will allow
        # our app to be validated by macOS even when an internet connection is not
        # available.
        xcrun stapler staple "${{ env.installer }}"

        spctl -a -tinstall -vvvv "${{ env.installer }}"
        xcrun stapler validate "${{ env.installer }}"

    - name: Post the installer
      uses: actions/upload-artifact@v4
      with:
        name: "macOS-installer"
        path: ${{ env.installer }}

