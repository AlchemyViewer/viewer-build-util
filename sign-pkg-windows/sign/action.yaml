name: sign-windows
description:
  Sign the specified Windows executable.

inputs:
  executable:
    decription: "Path to Windows executable to sign"
    type: string
    required: true
  retries:
    description: "Number of times to retry before failing"
    type: int
    required: false
    default: 6
  delay:
    description: "Initial delay before signing attempt"
    type: int
    required: false
    default: 5
  backoff_factor:
    description: "Multiply delay by this factor every retry"
    type: int
    required: false
    default: 2

runs:
  using: composite
  steps:
    - name: Sign
      shell: python
      env:
        BACKOFF: ${{ inputs.backoff_factor }}
        DELAY: ${{ inputs.delay }}
        EXECUTABLE: ${{ inputs.executable }}
        CERTIFICATE: authenticode-cert.pfx
        CERTIFICATE_EXPIRATION_WARNING: '14'
        RETRIES: ${{ inputs.retries }}
        TIMESTAMP_SERVICE: "[\"http://timestamp.globalsign.com/scripts/timstamp.dll\", \"http://timestamp.comodoca.com/authenticode\"]"
      run: |
        from datetime import datetime, timedelta
        import itertools
        import json
        import os
        import re
        import subprocess
        import sys
        import time

        executable =  os.getenv('EXECUTABLE')
        delay   = int(os.getenv('DELAY'))
        retries = int(os.getenv('RETRIES'))
        backoff = int(os.getenv('BACKOFF'))
        certificate = os.getenv('CERTIFICATE')
        certwarning = int(os.getenv('CERTIFICATE_EXPIRATION_WARNING'))
        services = json.loads(os.getenv('TIMESTAMP_SERVICE'))
        VerBinPath = os.getenv('WindowsSdkVerBinPath')
        assert VerBinPath, 'Must set $WindowsSdkVerBinPath'
        signtool=os.path.join(VerBinPath, 'X64', 'signtool.exe')
        assert os.path.isfile(signtool)

        # If we bang on the timestamp server too hard by signing executables
        # back-to-back, we may get throttled.
        # "Error: SignerSign() failed. (-1073700864/0xc000a000)"
        # may be throttle-related, and it somehow fails the build despite the
        # backoff loop meant to deal with it. (???)
        # At any rate, a small fixed delay may keep us out of throttle trouble.
        done = None
        for retry in range(retries):
            if retry:
                print(f'signing {retry} failed, ', end='', file=sys.stderr)
            print(f'waiting {delay} seconds', file=sys.stderr)
            time.sleep(delay)
            delay *= backoff
            # round-robin between listed services
            service = services[retry % len(services)]
            done = subprocess.run(
                [signtool, 'sign',
                '/f', certificate,
                '/t', service,
                '/d', 'Second Life Setup',
                '/fd', 'sha256',
                '/v',
                executable],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True)
            if done.returncode == 0:
                break
        else:
            print('Sign tool failed', file=sys.stderr)
            print(done.stdout, file=sys.stderr)
            sys.exit('Giving up...')

        ExpiresLine = re.compile(
            r"\bExpires:\s+\S{3}\s+(\S{3}) (\d+) \d\d:\d\d:\d\d (\d{4})"
        )  # looking for a date like 'Sep 16 23:59:59 2017'

        # Here the last of the retries succeeded, setting 'done'
        rc = done.returncode
        print('Signing succeeded')
        # Check the certificate expiration date in the output to warn of imminent expiration
        expiration = None
        for line in done.stdout.splitlines():
            print(line)
            found = ExpiresLine.search(line)
            if found:
                # month is an abbreviated name, translate
                try:
                    expiration = datetime.strptime(' '.join(found.groups()), '%b %d %Y')
                except ValueError:
                    print('failed to parse expiration from:', line, file=sys.stderr)
                    rc = 1
        if not expiration:
            sys.exit('Failed to find certificate expiration date')
        if expiration < datetime.now() + timedelta(certwarning):
            print(f'::warning::Certificate expires soon: {expiration}')
      
